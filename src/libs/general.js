import { EOL } from "node:os";
import { join, sep } from "node:path";
import { open } from "node:fs";
import { rm, copyFile, chown, chmod, opendir, access } from "node:fs/promises";
import { asyncExec } from "../../index.js";
import { logger } from "./logger.js";
import { QEMU_HOOK_DIR } from "./hooks.js";
import { domainExists } from "./virsh.js";

/**
 * Returns a list of IOMMU groups with their devices.
 *
 * @returns {Promise<Map<number, Array<{pciAddress: string, description: string}>>>}
 *          Map of IOMMU group number to array of devices in that group
 */
const fetchIommuGroups = async () => {
  // Get all device symlinks with their full paths to preserve group numbers
  const findCommand = "find /sys/kernel/iommu_groups/*/devices/* -maxdepth 0 2>/dev/null | sort -t/ -k5 -n";

  const { stdout: findStdout } = await asyncExec(findCommand);

  const devicePaths = findStdout.split(EOL).filter((d) => d.length > 0);

  const groups = new Map();

  for (const devicePath of devicePaths) {
    // Extract group number and PCI address from path like:
    // /sys/kernel/iommu_groups/12/devices/0000:07:00.0
    const match = devicePath.match(/\/iommu_groups\/(\d+)\/devices\/(.+)$/);
    if (!match) continue;

    const groupNum = parseInt(match[1], 10);
    const pciAddress = match[2];

    // Get device description from lspci
    const { stdout: lspciOut } = await asyncExec(`lspci -nns ${pciAddress}`);
    const description = lspciOut.trim();

    if (!groups.has(groupNum)) {
      groups.set(groupNum, []);
    }

    groups.get(groupNum).push({
      pciAddress,
      description,
    });
  }

  return groups;
};

/**
 * Looks for domains already using hooks generated by qemu-hook-manager.
 *
 * @returns a list of active domains
 */
const fetchActiveDomains = async () => {
  const command = ["ls", join("/etc", "libvirt", "hooks", "qemu.d")];

  try {
    const { stdout } = await asyncExec(command.join(" "));

    return stdout.split(EOL).filter((d) => d.length > 0);
    // eslint-disable-next-line no-unused-vars
  } catch (error) {
    return [];
  }
};

/**
 * Enables passthrough for a domain.
 *
 * @param {string} domain the domain to enable passthrough for
 * @returns the stdout from a symlink command
 */
const enablePassthrough = async (domain) => {
  const command = [
    "ln",
    "-s",
    join(QEMU_HOOK_DIR, "qemu.d", ".qhm-passthrough"),
    join(QEMU_HOOK_DIR, "qemu.d", domain),
  ];

  const { stdout, stderr } = await asyncExec(command.join(" "));

  if (stderr) {
    throw new Error(stderr);
  }

  return stdout;
};

/**
 * Disables passthrough for a domain.
 *
 * @param {string} domain the domain to disable passthrough for
 * @returns the stdout from an unlink command
 */
const disablePassthrough = async (domain) => {
  const command = ["unlink", join(QEMU_HOOK_DIR, "qemu.d", domain)];

  const { stdout, stderr } = await asyncExec(command.join(" "));

  if (stderr) {
    throw new Error(stderr);
  }

  return stdout;
};

/**
 * Installs a script by name from the qemu_hook_skeleton directory to the
 * specified destination and makes it executable.
 *
 * @param {string} scriptName the name of the script to install
 * @param {PathLike} destination the destination directory to install the script
 * @param {PathLike} destinationScriptName the name of the script when installed to the destination directory
 */
const installScript = async (
  source,
  destination,
  destinationScriptName = undefined
) => {
  destinationScriptName = destinationScriptName || source.split(sep).pop();

  const destinationPath = join(destination, destinationScriptName);

  if (await fileExists(destinationPath)) {
    logger.info(`Removing existing script: ${destinationPath}`);

    await rm(destinationPath, {
      force: true,
      recursive: true,
    });
  }

  await copyFile(source, destinationPath);

  await chown(destinationPath, 0, 0);

  await chmod(destinationPath, "755");
};

/**
 * Checks the filesystem for a the existence of a file by reading from it to get
 * around race conditions.
 *
 * @param {PathLike} path the pathe to check for existence
 */
const fileExists = async (path) => {
  try {
    open(path, "r", (error) => {
      if (error) {
        logger.debug(`Error opening file: ${path}`);
      }
    });

    return true;
  // eslint-disable-next-line no-unused-vars
  } catch (error) {
    return false;
  }
};

/**
 * Checks the filesystem for a the existence of a directory.
 * 
 * @param {PathLike} path the path to the directory to check for existence
 * @returns true if the directory exists, false otherwise
 */
const dirExists = async (path) => {
  try {
    await access(path);

    return true;
  // eslint-disable-next-line no-unused-vars
  } catch (error) {
    return false;
  }
};

/**
 * List the contents of a directory.
 * 
 * @param {PathLike} path the path to the dorectory to list contents for
 * @returns a list of directory entries or {} if the directory does not exist or is empty
 */
const ls = async (path) => {
  try {
    return await opendir(path);
  // eslint-disable-next-line no-unused-vars
  } catch (error) {
    return {};
  }
};

/**
 * Filters the incoming answers to remove any invalid or non-existent IOMMU 
 * groups or domains.
 * 
 * @param {object} answers the user supplied answers to filter
 * @returns a filtered version of the incoming answers
 */
const filterAnswers = async (answers) => {
  const filteredAnswers = {
    iommuGroups: [],
    domains: [],
  }

  for (const [k, v] of Object.entries(answers)) {
    if (k === "iommuGroups") {
      const iommuGroups = Array.isArray(v) ? v : [v];

      for (const group of iommuGroups) {
        if (/^[\da-f]{2}:[\da-f]{2}\.[\da-f]$/.test(group)) {
          filteredAnswers.iommuGroups.push(group);
        } else {
          logger.warn(`Invalid IOMMU group: ${group}`);
        }
      }
    } else if (k === "domains") {
      const domains = Array.isArray(v) ? v : [v];

      for (const domain of domains) {
        if (await domainExists(domain)) {
          filteredAnswers.domains.push(domain);
        } else {
          logger.warn(`Domain ${domain} does not exist`);
        }
      }
    } else if (k === "useOwnHooks") {
      filteredAnswers[k] = v === "yes";
    } else {
      filteredAnswers[k] = v;
    }
  }

  return filteredAnswers;
}

export {
  fetchIommuGroups,
  fetchActiveDomains,
  enablePassthrough,
  disablePassthrough,
  installScript,
  fileExists,
  dirExists,
  ls,
  filterAnswers,
};
