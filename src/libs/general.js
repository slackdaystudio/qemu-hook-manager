import { EOL } from "node:os";
import { join } from "node:path";
import { open } from "node:fs";
import { rm, copyFile, chown, chmod } from "node:fs/promises";
import { asyncExec, SKELETON_DIR } from "../../index.js";
import { logger } from "./logger.js";
import { PREPARE_HOOK_PATH, QEMU_HOOK_DIR } from "./hooks.js";

/**
 * Returns a list of IOMMU groups.
 * 
 * @returns a list of IOMMU groups, one record per line, sorted by group number
 */
const fetchIommuGroups = async () => {
  const command = [
    "find",
    "/sys/kernel/iommu_groups/",
    "-type l",
    "-exec",
    "basename",
    "{}",
    "\\;",
    "|",
    "sort",
    "|",
    "xargs",
    "-I",
    "%",
    "lspci",
    "-nns",
    "%",
  ];

  const { stdout, stderr } = await asyncExec(command.join(" "));

  if (stderr) {
    throw new Error(stderr);
  }

  return stdout.split(EOL).filter((d) => d.length > 0);
};

/**
 * Looks for domains already using hooks generated by qemu-hook-manager.
 * 
 * @returns a list of active domains
 */
const fetchActiveDomains = async () => {
  const command = ["ls", join("/etc", "libvirt", "hooks", "qemu.d")];

  try {
    const { stdout } = await asyncExec(command.join(" "));
  
    return stdout.split(EOL).filter((d) => d.length > 0);
  // eslint-disable-next-line no-unused-vars
  } catch (error) {
    return [];
  }
};

/**
 * Enables passthrough for a domain.
 * 
 * @param {string} domain the domain to enable passthrough for 
 * @returns the stdout from a symlink command
 */
const enablePassthrough = async (domain) => {
  const command = [
    "ln",
    "-s",
    join(QEMU_HOOK_DIR, "qemu.d", ".gpu-passthrough"),
    join(QEMU_HOOK_DIR, "qemu.d", domain),
  ];

  const { stdout, stderr } = await asyncExec(command.join(" "));

  if (stderr) {
    throw new Error(stderr);
  }

  return stdout;
};

/**
 * Disables passthrough for a domain.
 * 
 * @param {string} domain the domain to disable passthrough for
 * @returns the stdout from an unlink command
 */
const disablePassthrough = async (domain) => {
  const command = ["unlink", join(QEMU_HOOK_DIR, "qemu.d", domain)];

  const { stdout, stderr } = await asyncExec(command.join(" "));

  if (stderr) {
    throw new Error(stderr);
  }

  return stdout;
};

/**
 * Installs a script by name from the qemu_hook_skeleton directory to the 
 * specified destination and makes it executable.
 * 
 * @param {string} scriptName the name of the script to install
 * @param {PathLike} destination the destination directory to install the script
 * @param {PathLike} destinationScriptName the name of the script when installed to the destination directory
 */
const installScript = async (
  scriptName,
  destination,
  destinationScriptName = undefined
) => {
  destinationScriptName = destinationScriptName || scriptName;

  const destinationPath = join(destination, destinationScriptName); 

  if (await fileExists(destinationPath)) {
    logger.info(`Removing existing script: ${destinationPath}`);

    await rm(destinationPath, {
      force: true,
      recursive: true,
    });
  }

  await rm(PREPARE_HOOK_PATH, {
    force: true,
    recursive: true,
  });

  await copyFile(
    join(SKELETON_DIR, scriptName),
    destinationPath
  );

  await chown(destinationPath, 0, 0);

  await chmod(destinationPath, "755");
};

/**
 * Checks the filesystem for a the existence of a file by reading from it to get
 * around race conditions.
 * 
 * @param {PathLike} path the pathe to check for existence
 */
const fileExists = async (path) => {
  open(path, 'r', (error) => {
    if (error) {
      return false;
    } else {
      return true;
    }
  });
};

export {
  fetchIommuGroups,
  fetchActiveDomains,
  enablePassthrough,
  disablePassthrough,
  installScript,
  fileExists,
};
